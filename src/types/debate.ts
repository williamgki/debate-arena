// Core debate storage system types
// This implements a scalable, multi-format debate storage architecture

export type UUID = string;
export type ISO8601 = string;

// ==================== CORE PARTICIPANT SYSTEM ====================

export interface ParticipantInfo {
  id: UUID;
  role: 'debaterA' | 'debaterB' | 'judge' | 'moderator' | 'observer' | 'system';
  type: 'human' | 'ai' | 'system';
  name: string;
  model?: string; // For AI participants
  capabilities?: string[];
  sessionInfo?: {
    ip?: string;
    userAgent?: string;
    sessionId?: string;
  };
}

// ==================== NODE SYSTEM ====================

export type RelationshipType = 
  | 'responds-to'    // Direct response to an argument
  | 'supports'       // Supporting evidence/argument
  | 'refutes'        // Counter-argument
  | 'clarifies'      // Clarification or elaboration
  | 'questions'      // Poses a question about
  | 'summarizes'     // Summary of multiple arguments
  | 'judges'         // Judgment/evaluation of argument

export interface NodeRelationship {
  targetNodeId: UUID;
  type: RelationshipType;
  strength?: number; // 0-1, how strong the relationship is
  metadata?: Record<string, any>;
}

export type NodeFlag = 
  | 'obfuscated'        // Intentionally unclear
  | 'logical_flaw'      // Contains logical fallacy
  | 'ad_hominem'        // Personal attack
  | 'strawman'          // Misrepresents opponent
  | 'red_herring'       // Off-topic distraction
  | 'appeal_to_emotion' // Emotional manipulation
  | 'circular_reasoning' // Circular logic
  | 'false_dichotomy'   // False either/or choice
  | 'slippery_slope'    // Unwarranted chain of consequences
  | 'highlighted'       // Marked as important
  | 'archived'          // No longer active
  | 'disputed'          // Under dispute
  | 'verified'          // Fact-checked
  | 'ai_generated'      // Generated by AI
  | 'human_authored'    // Written by human
  | 'low_quality'       // Poor argument quality
  | 'high_quality'      // Exceptional argument

export interface NodeMetrics {
  selfScore?: number;        // 1-10 from author
  confidenceLevel?: number;  // 0-1 author's confidence
  complexityScore?: number;  // Computed text complexity
  readabilityScore?: number; // Flesch-Kincaid or similar
  wordCount?: number;
  averageJudgmentScore?: number; // Average of all judgments
  flagCount?: Record<NodeFlag, number>;
}

export interface NodePosition {
  depth: number;           // Distance from root
  threadId: UUID;         // Which conversation thread
  sequenceInThread: number; // Order within thread
  branchPoint?: UUID;     // Node where this branch started
}

export interface DebateNode {
  id: UUID;
  
  // Content
  content: {
    text: string;
    attachments?: Array<{
      type: 'image' | 'document' | 'link' | 'code';
      url: string;
      metadata?: Record<string, any>;
    }>;
    formatting?: {
      markdown?: boolean;
      html?: boolean;
    };
  };
  
  // Authorship
  participantId: UUID;
  
  // Temporal
  timestamps: {
    created: ISO8601;
    lastModified?: ISO8601;
    finalized?: ISO8601; // When editing was locked
  };
  
  // Relationships
  relationships: {
    parents: NodeRelationship[];
    children: NodeRelationship[];
    siblings?: NodeRelationship[]; // Related nodes at same level
  };
  
  // Position in debate structure
  position: NodePosition;
  
  // Classification
  flags: NodeFlag[];
  metrics: NodeMetrics;
  
  // Version control
  version: number;
  editHistory?: Array<{
    timestamp: ISO8601;
    participantId: UUID;
    changes: Record<string, any>;
  }>;
}

// ==================== ANNOTATION SYSTEM ====================

export type AnnotationType = 
  | 'judgment'      // Evaluation of argument quality
  | 'flag'          // Flag for issues
  | 'score'         // Numerical rating
  | 'analysis'      // Detailed analysis
  | 'cross_ref'     // Reference to other debates/nodes
  | 'fact_check'    // Verification of claims
  | 'summary'       // Summary of discussion
  | 'insight'       // AI-generated insight

export interface Annotation {
  id: UUID;
  type: AnnotationType;
  
  // Target
  targetNodeId: UUID;
  targetSpan?: {
    start: number;
    end: number;
  };
  
  // Content
  content: {
    text?: string;
    score?: number;
    confidence?: number;
    evidence?: string[];
    metadata?: Record<string, any>;
  };
  
  // Authorship
  annotatorId: UUID;
  timestamp: ISO8601;
  
  // Visibility
  visibility: 'public' | 'private' | 'moderator_only';
}

// ==================== DEBATE DOCUMENT ====================

export type DebateStatus = 'draft' | 'active' | 'paused' | 'completed' | 'archived';
export type DebateFormat = 'tree' | 'linear' | 'structured' | 'freestyle';
export type AccessLevel = 'public' | 'unlisted' | 'private' | 'restricted';

export interface DebateMetadata {
  id: UUID;
  version: string; // Schema version for migrations
  
  // Basic info
  topic: {
    title: string;
    description?: string;
    tags: string[];
    category?: string;
  };
  
  // Temporal
  timestamps: {
    created: ISO8601;
    lastModified: ISO8601;
    started?: ISO8601;
    completed?: ISO8601;
  };
  
  // Status
  status: DebateStatus;
  format: DebateFormat;
  
  // Configuration
  configuration: {
    maxDepth?: number;
    maxNodesPerParent?: number;
    allowObfuscation?: boolean;
    scoringMethod?: string;
    moderationLevel?: 'none' | 'light' | 'strict';
    allowPublicJudging?: boolean;
  };
  
  // Access control
  access: {
    level: AccessLevel;
    permissions?: Record<UUID, string[]>;
    moderators?: UUID[];
  };
  
  // Analytics
  analytics: {
    totalNodes: number;
    totalParticipants: number;
    totalJudgments: number;
    totalFlags: number;
    averageDepth: number;
    longestThread: number;
    participationDistribution?: Record<UUID, number>;
  };
}

export interface DebateDocument {
  metadata: DebateMetadata;
  participants: Record<UUID, ParticipantInfo>;
  nodes: Record<UUID, DebateNode>;
  annotations: Record<UUID, Annotation>;
  
  // Computed/cached data
  threads?: Record<UUID, UUID[]>; // Thread ID -> ordered node IDs
  rootNodeId: UUID;
  
  // Export metadata
  exportInfo?: {
    format: string;
    timestamp: ISO8601;
    exportedBy: UUID;
    version: string;
  };
}

// ==================== SEARCH AND QUERY ====================

export interface SearchQuery {
  // Text search
  text?: string;
  textFields?: ('content' | 'topic' | 'annotations')[];
  
  // Structural search
  participantIds?: UUID[];
  nodeFlags?: NodeFlag[];
  relationshipTypes?: RelationshipType[];
  depthRange?: [number, number];
  
  // Temporal search
  dateRange?: [ISO8601, ISO8601];
  
  // Metric search
  scoreRange?: [number, number];
  
  // Metadata search
  tags?: string[];
  categories?: string[];
  status?: DebateStatus[];
  format?: DebateFormat[];
  
  // Result options
  limit?: number;
  offset?: number;
  sortBy?: 'created' | 'modified' | 'relevance' | 'score';
  sortOrder?: 'asc' | 'desc';
  
  // Include options
  includeNodes?: boolean;
  includeAnnotations?: boolean;
  includeAnalytics?: boolean;
}

export interface SearchResult {
  debates: DebateDocument[];
  totalCount: number;
  facets?: {
    participants?: Record<string, number>;
    tags?: Record<string, number>;
    flags?: Record<string, number>;
    timeDistribution?: Record<string, number>;
  };
}

// ==================== EXPORT FORMATS ====================

export type ExportFormat = 
  | 'json'          // Full JSON format
  | 'json-ld'       // Semantic web format
  | 'markdown'      // Human-readable
  | 'csv'           // Tabular data
  | 'graphml'       // Network analysis
  | 'aif'           // Argument Interchange Format
  | 'html'          // Web page
  | 'pdf'           // Document

export interface ExportOptions {
  format: ExportFormat;
  includeAnnotations?: boolean;
  includeMetrics?: boolean;
  includeEditHistory?: boolean;
  flattenStructure?: boolean; // For linear formats
  anonymizeParticipants?: boolean;
  customTemplate?: string;
}

export interface ExportResult {
  data: string | Buffer;
  mimeType: string;
  filename: string;
  metadata: {
    debateId: UUID;
    exportedAt: ISO8601;
    format: ExportFormat;
    options: ExportOptions;
  };
}

// ==================== API RESPONSE TYPES ====================

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  pagination?: {
    total: number;
    page: number;
    limit: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

// Helper types for common operations
export type CreateDebateRequest = Omit<DebateMetadata, 'id' | 'timestamps' | 'analytics'> & {
  initialTopic: string;
  participants: ParticipantInfo[];
};

export type AddNodeRequest = Omit<DebateNode, 'id' | 'timestamps' | 'position' | 'version'> & {
  debateId: UUID;
  parentNodeIds?: UUID[]; // For multi-parent nodes
};

export type AddAnnotationRequest = Omit<Annotation, 'id' | 'timestamp'> & {
  debateId: UUID;
};